I"i<p>The non auto-correlated model is convenient and easy to implement. However, empirically, it is not so adequate. The main reason is that the rate of evolution tends to show strong auto-correlation between neighbouring branches. Just think, for instance, that the rate of evolution is partly determined by the generation time (species with longer generation times tend to be more slowly evolving). Yet closely related species tend to have similar generation times. In other words, the generation time (and therefore the substitution rate) shows phylogenetic inertia.</p>

<p>One way to account for this auto-correlation is to assume that the logarithm of the substitution rate evolves along the tree according to a Brownian model. This idea has been implemented in several software programs, such as MultiDivTime, PhyloBayes or Coevol.</p>

<p>Specifically, consider a trait $X$, evolving according to a Brownian process, with variance $\sigma^2$ per unit of time. This means that, given the value of the trait at some time $t$, $X(t)$, then, the value of the trait at time $t+\Delta t$ is normally distributed, of mean $X(t)$ and of variance $\sigma^2 \Delta t$:</p>

\[X(t + \Delta t) \sim Normal \left( X(t), \sigma^2 \Delta t \right)\]

<p>We can use this equation to model the distribution of the substitution rates at the nodes of the tree: consider some node $n$ of the tree, other than the root, and which lives at time $u$. Consider the node immediately before node $n$ (the parent of $n$), and call it $m$. Node $m$ lives at time $t &lt; u$.  Let $X(t)$ denote the log of the rate at node $m$. Then, according to the equation above, $X(u)$ is normally distributed, as follows:</p>

<p>\(X(u) \sim Normal(X(t), \sigma^2 (t-u))\)
Note that $t-u$ is just the length of the branch starting at node $m$ and ending at node $n$.</p>

<p>With this equation, we can define the log of the substitution rate (or, more briefly, log-rate) at each node (other than the root) as a normally-distributed random variable, whose distribution depends on the log-rate of the parent node. The exception is the root node, which does not have a parent. So, we need to define a prior distribution for the value of the log of the substitution rate at the root.</p>

<p>In practice, we need to proceed in the other direction: first specifying the log-rate at the root, then, going from the root to the tips of the tree, and specifying the distribution of the log-rate at each node, conditional on its parent. In RevBayes, the nodes are indexed starting from the tips, and ending at the root. Therefore, we should specify them by visiting the indices in a decreasing order.</p>

<p>First, we define the number of nodes:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n_nodes &lt;- 2 * n_species - 1
</code></pre></div></div>
<p>Then we should define the sigma parameter (the variance per unit of time of the Brownian motion):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sigma ~ dnExponential(1.0)
</code></pre></div></div>
<p>Next, we should specify the log-rate at the root, which has index n_nodes. Here, we use a vaguely informative prior, with a rate of mean around $0.1$, but with a large variance:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nodelograte[n_nodes] ~ dnNormal(mean=-2, sd=20)
</code></pre></div></div>
<p>Then, we visit the nodes in decreasing order (from root to tips):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in (n_nodes-1):1)    {
    nodelograte[i] ~ dnNormal(mean=nodelograte[tree.parent(i)], sd=sigma * sqrt(tree.branchLength(i)))
}
</code></pre></div></div>

<p>Once this is done, we still need to specify (or, in fact, to approximate), the mean substitution rate over each branch. We will use the following approximation: the rate on a given branch is the average of the rates at both ends. The rates at both ends are themselves obtained by taking the exponential of the log-rates at both ends. Altogether, we have to loop over all branches as follows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_branches) {
    clockrate[i] := 0.5 * (exp(nodelograte[tree.parent(i)]) + exp(nodelograte[i]))
}
</code></pre></div></div>

<p>Finally, we can use these rates across branches in our sequence evolutionary process:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC( tree=timetree, Q=Q, branchRates=clockrate, type="DNA" )
</code></pre></div></div>

<p>Again, we should move all of the additional free parameters of the model: here, a scaling move for sigma:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append(mvScale(sigma, weight=1.0))
</code></pre></div></div>
<p>but also a sliding move for each of the log-rates across nodes.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:n_nodes) {
    moves.append(mvSlide(nodelograte[i], weight=1.0))
}
</code></pre></div></div>

<p>For the rest, the script unfolds as usual.</p>

<p>Write the complete script, using <code class="highlighter-rouge">prim_strictclock.rev</code> as a template and making the required changes. Run the script on the primate dataset, and compare your estimation with the other clock models considered above.</p>
:ET