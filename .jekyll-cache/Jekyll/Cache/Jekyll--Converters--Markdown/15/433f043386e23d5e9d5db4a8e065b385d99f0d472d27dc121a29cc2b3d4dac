I"I£<p>This tutorial demonstrates how to set up a Jukes and Cantor (1969, herafter
named JC) model of
nucleotide substitution, and then how to perform simulations and phylogenetic
inference using this model.
JC is the simplest model for describing nucleotide sequence evolution. It is
a continuous time Markov chain (ctmc) model. In general ctmc models are
fully characterized by their instantaneous-rate matrix:</p>

\[Q = \begin{pmatrix}
-\mu_A &amp; \mu_{AC} &amp; \mu_{AG} &amp; \mu_{AT} \\
\mu_{CA} &amp; -\mu_C  &amp; \mu_{CG} &amp; \mu_{CT} \\
\mu_{GA} &amp; \mu_{GC} &amp; -\mu_C  &amp; \mu_{GT} \\
\mu_{TA} &amp; \mu_{TC} &amp; \mu_{TG} &amp; -\mu_T
\end{pmatrix} \mbox{  ,}\]

<p>where $\mu_{ij}$ represents the instantaneous rate of substitution from
state $i$ to state $j$. The diagonal elements $\mu_i$ are the rates of
<em>not</em> changing out of state $i$, equal to the sum of the elements in the
corresponding row. Given the instantaneous-rate matrix, $Q$, we can
compute the corresponding transition probabilities for a branch of
length $l$, $P(l)$, by exponentiating the rate matrix:</p>

\[P(l) = \begin{pmatrix}
p_{AA}(l) &amp; p_{AC}(l) &amp; p_{AG}(l) &amp; p_{AT}(l) \\
p_{CA}(l) &amp; p_{CC}(l) &amp; p_{CG}(l) &amp; p_{CT}(l) \\
p_{GA}(l) &amp; p_{GC}(l) &amp; p_{GG}(l) &amp; p_{GT}(l) \\
p_{TA}(l) &amp; p_{TC}(l) &amp; p_{TG}(l) &amp; p_{TT}(l)
\end{pmatrix} = e^{Ql} = \sum_{j=0}^\infty\frac{(Ql)^j}{j!} \mbox{  .}\]

<p>Each of the named substitution models (e.g., JC, TN92, HKY or GTR)
has a uniquely defined instantaneous-rate matrix, $Q$.</p>

<p>In this tutorial you will perform phylogeny inference under the simplest
model of DNA sequence evolution: JC. In the next tutorial, you will explore
other models with names such as F81, HKY85, TN92, GTR, GTR+Gamma.
In this tutorial, you will first simulate sequences using the JC model, and
then perform phylogenetic inference from a sequence alignment.
This inference will be based on the Markov chain Monte Carlo (MCMC) algorithm to
 estimate the phylogeny and other model parameters such as branch lengths. The
estimated trees will be unrooted trees with independent branch-length
parameters.</p>

<figure id="tab_subst_models" class="table"><figcaption class="table">Specific functions for substitution models available in RevBayes.</figcaption>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>Model</strong></th>
      <th style="text-align: center"><strong>Reference</strong></th>
      <th style="text-align: center"><strong>Function</strong></th>
      <th style="text-align: center"><strong>Parameters</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Jukes-Cantor</td>
      <td style="text-align: center"><a class="citation" href="#Jukes1969">(Jukes and Cantor 1969)</a></td>
      <td style="text-align: center">fnJC</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">K80 (a.k.a. K2P)</td>
      <td style="text-align: center"><a class="citation" href="#Kimura1980">(Kimura 1980)</a></td>
      <td style="text-align: center">fnK80</td>
      <td style="text-align: center">$\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">Felsenstein-81</td>
      <td style="text-align: center"><a class="citation" href="#Felsenstein1981">(Felsenstein 1981)</a></td>
      <td style="text-align: center">fnF81</td>
      <td style="text-align: center">$\pi$</td>
    </tr>
    <tr>
      <td style="text-align: center">T92</td>
      <td style="text-align: center"><a class="citation" href="#Tamura1992">(Tamura 1992)</a></td>
      <td style="text-align: center">fnT92</td>
      <td style="text-align: center">$\pi_{GC}$, $\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">HKY</td>
      <td style="text-align: center"><a class="citation" href="#Hasegawa1985">(Hasegawa et al. 1985)</a></td>
      <td style="text-align: center">fnHKY</td>
      <td style="text-align: center">$\pi$, $\kappa$</td>
    </tr>
    <tr>
      <td style="text-align: center">GTR</td>
      <td style="text-align: center"><a class="citation" href="#Tavare1986">(Tavar√© 1986)</a></td>
      <td style="text-align: center">fnGTR</td>
      <td style="text-align: center">$\pi$, $\epsilon$</td>
    </tr>
  </tbody>
</table>
</figure>

<h2 class="section" id="character-evolution-under-the-jukes-cantor-substitution-model">Character Evolution under the Jukes-Cantor Substitution Model</h2>
<hr class="section" />

<h3 class="subsection" id="getting-started">Getting Started</h3>
<hr class="subsection" />

<p>This tutorial involves:</p>
<ol>
  <li>setting up a Jukes-Cantor (JC) substitution model for an alignment of the cytochrome b subunit;</li>
  <li>simulating DNA sequence evolution;</li>
  <li>approximating the posterior probability of the tree topology and branch
lengths using MCMC;</li>
  <li>summarizing the MCMC output by computing the maximum <em>a posteriori</em> tree.</li>
</ol>

<figure id="jc_graphical_model"><p><img src="figures/jc_graphical_model.png" /></p>
<figcaption>Graphical model representation of a simple phylogenetic model. The graphical model shows the dependencies among parameters <a class="citation" href="#Hoehna2014b">(H√∂hna et al. 2014)</a>. Here, the rate matrix $Q$ is a constant variable because it is fixed and does not depend on any parameter. The only free parameters of this model, based on the Jukes-Cantor model of substitution, are the tree $\Psi$ including the branch lengths.</figcaption>
</figure>

<p>We first consider the simplest substitution model described by
<a class="citation" href="#Jukes1969">Jukes and Cantor (1969)</a>. The instantaneous-rate matrix for the JC substitution
model is defined as</p>

\[Q_{JC} = \begin{pmatrix}
{*} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; {*} &amp; \frac{1}{3} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; \frac{1}{3} &amp; {*} &amp; \frac{1}{3} \\
\frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; {*}
\end{pmatrix} \mbox{  ,}\]

<p>which has the advantage that the transition probability matrix can be
computed analytically</p>

\[P_{JC} = \begin{pmatrix} {\frac{1}{4} + \frac{3}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} \\\\ {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} - \frac{1}{4}e^{-l}} &amp; {\frac{1}{4} + \frac{3}{4}e^{-l}}
\end{pmatrix} \mbox{  ,}\]

<p>where $l$ is the branch length in units of expected numbers of substitutions, which corresponds to the product of the time and the rate of substitution. <strong>Don‚Äôt worry, you won‚Äôt have to calculate all of the transition probabilities, because RevBayes will take care of all the computations for you.</strong> Here we only provide some of the equations for the models in case you might be interested in the details. You will be able to complete the exercises without understanding the underlying math.</p>

<h3 class="subsection" id="simulating-a-dna-alignment">Simulating a DNA alignment</h3>
<hr class="subsection" />

<p>The files for this example analysis are provided for you (<a href="scripts/simulation_JC.Rev"><code class="highlighter-rouge">simulation_JC.Rev</code></a>).
If you download this file and place it in a directory called <code class="highlighter-rouge">scripts</code> inside your main tutorial directory,
you can easily execute this analysis using the <code class="highlighter-rouge">source()</code> function in the RevBayes console:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/simulation_JC.Rev")
</code></pre></div></div>

<p>This simulation should be fast, and should have produced two files in the
folder <code class="highlighter-rouge">data</code>: <code class="highlighter-rouge">simulatedSequences_1.fasta</code> and <code class="highlighter-rouge">simulatedSequences_2.fasta</code>.</p>

<p>Below we are going to go through the script and explain what it does, step by step.</p>

<h4 class="subsubsection" id="loading-the-data">Loading the Data</h4>
<hr class="subsubsection" />

<p>The first thing the script does is to load a DNA alignment. Although this step is
not necessary for simulating an alignment, here we use the empirical alignment
just to get its number of sequences, its number of sites, and the sequence names.</p>

<blockquote class="aside"><h2>Checking and Changing Your Working Directory</h2><p>For this tutorial and much of the work you will do in RevBayes, you will need to access files.
It is important that you are aware of your current working directory if you use relative file paths
in your Rev scripts or in the RevBayes console.</p>

<p>To check your current working directory, use the function <code class="highlighter-rouge">getwd()</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getwd()
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/tombayes/Work
</code></pre></div></div>

<p>If you want to change the directory, enter the path to your directory in the arguments of the function <code class="highlighter-rouge">setwd()</code>.</p>

<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setwd("Tutorials/RB_CTMC_Tutorial")
</code></pre></div></div>

<p>Now check your directory again to make sure you are where you want to be:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getwd()
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/Users/tombayes/Work/Tutorials/RB_CTMC_Tutorial
</code></pre></div></div>
</blockquote>

<p>We load in the sequences using the <code class="highlighter-rouge">readDiscreteCharacterData()</code>
function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data &lt;- readDiscreteCharacterData("data/primates_and_galeopterus_cytb.nex")
</code></pre></div></div>

<p>Executing this line initializes the data matrix as a variable in the Rev
environment. You can have a look at the list of variables in the environment as
follows:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls()
</code></pre></div></div>

<p>To report the current value of any variable, simply
type the variable name and press enter. For the <code class="highlighter-rouge">data</code> matrix, this
provides information about the alignment:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   DNA character matrix with 23 taxa and 1141 characters
   =====================================================
   Origination:                      primates_and_galeopterus_cytb.nex
   Number of taxa:                   23
   Number of included taxa:          23
   Number of characters:             1141
   Number of included characters:    1141
   Datatype:                         DNA
</code></pre></div></div>

<p>Next we will specify some useful variables based on our dataset. The variable
<code class="highlighter-rouge">data</code> has <em>member functions</em> that we can use to retrieve information about the
dataset. These include, for example, the number of species and the taxa.
We will need that taxon information for setting up different parts of our model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>num_taxa &lt;- data.ntaxa()
num_branches &lt;- 2 * num_taxa - 3
taxa &lt;- data.taxa()
num_sites &lt;- data.nchar()
</code></pre></div></div>

<ul>
  <li><strong>Why are we using ‚Äú&lt;-‚Äú and not ‚Äú:=‚Äù or ‚Äú~‚Äù?</strong></li>
</ul>

<p>With the data loaded, we can now proceed to specifying the model.</p>

<h4 class="subsubsection" id="setting-up-the-graphical-model">Setting up the Graphical Model</h4>
<hr class="subsubsection" />

<p>Simulating DNA sequences with an unrooted tree under the JC model requires
specification of two main components:
(1) the <a href="#subsub-JCMod"></a> and (2) the <a href="#subsub-TreeBlMod"></a>.</p>

<h4 class="subsubsubsection" id="subsub-JCMod">Jukes-Cantor Substitution Model</h4>
<hr class="subsubsubsection" />

<p>A given substitution model is defined by its corresponding
instantaneous-rate matrix, $Q$. The Jukes-Cantor substitution model does
not have any free parameters (as the substitution rates are all assumed
to be equal), so we can define it as a constant variable. The function
<code class="highlighter-rouge">fnJC(n)</code> will create an instantaneous-rate matrix for a character with
$n$ states. Since we use DNA data here, we create a 4x4
instantaneous-rate matrix:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q &lt;- fnJC(4)
</code></pre></div></div>

<ul>
  <li><strong>What does the ‚Äú4‚Äù stand for?</strong></li>
</ul>

<p>You can see the rates of the $Q$ matrix by typing</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Q
</code></pre></div></div>
<div class="Rev-output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   [ [ -1.0000, 0.3333, 0.3333, 0.3333 ] ,
     0.3333, -1.0000, 0.3333, 0.3333 ] ,
     0.3333, 0.3333, -1.0000, 0.3333 ] ,
     0.3333, 0.3333, 0.3333, -1.0000 ] ]
</code></pre></div></div>

<p>As you can see, all substitution rates are equal.</p>

<h4 class="subsubsubsection" id="subsub-TreeBlMod">Tree Topology and Branch Lengths</h4>
<hr class="subsubsubsection" />

<p>The tree topology and branch lengths are stochastic nodes in our phylogenetic model.
In <a href="#jc_graphical_model"></a>, the tree topology is denoted $\Psi$ and the
length of the branch leading to node $i$ is $bl_i$.</p>

<p>We will assume that all possible labeled, unrooted tree topologies have equal probability.
This is the <code class="highlighter-rouge">dnUniformTopology()</code> distribution in RevBayes.
Note that in RevBayes it is advisable to specify the outgroup for your study system
if you use an unrooted tree prior, whereas other software, such as
MrBayes, use the first taxon in the data matrix file as the outgroup.
Providing RevBayes with an outgroup clade will make sure that when trees are
written to file, the topologies have the outgroup clade at the base,
thus making the trees easier to visualize.</p>

<ul>
  <li><strong>Does the root position of the tree matter for the JC model?</strong></li>
</ul>

<p>Specify the <code class="highlighter-rouge">topology</code> stochastic node by passing in the list of <code class="highlighter-rouge">taxa</code>
to the <code class="highlighter-rouge">dnUniformTopology()</code> distribution:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>out_group = clade("Galeopterus_variegatus")
topology ~ dnUniformTopology(taxa, outgroup=out_group)
</code></pre></div></div>

<p>Next we have to create a stochastic node representing the length of each of the
$2N - 3$ branches in our tree (where $N=$ <code class="highlighter-rouge">n_species</code>). We can do this using a
<code class="highlighter-rouge">for</code> loop ‚Äî this is a plate in our graphical model. In this loop, we can
create each of the branch-length nodes. Copy this entire
block of Rev¬†code into the console:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:num_branches) {
   br_lens[i] ~ dnExponential(10.0)
}
</code></pre></div></div>

<p>Finally, we can create a <em>phylogram</em> (a phylogeny in which the branch lengths are
proportional to the expected number of substitutions per site) by combining the
tree topology and branch lengths. We do this using the <code class="highlighter-rouge">treeAssembly()</code> function,
which applies the value of the $i^{th}$ member of the <code class="highlighter-rouge">br_lens</code> vector to the
branch leading to the $i^{th}$ node in <code class="highlighter-rouge">topology</code>. Thus, the <code class="highlighter-rouge">psi</code> variable is
a deterministic node:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psi := treeAssembly(topology, br_lens)
</code></pre></div></div>

<blockquote class="aside"><h2>Alternative tree priors</h2><p>For large phylogenetic trees, i.e., with more than 200 taxa, it might be more
efficient to specify a combined topology and branch length prior distribution.
We can achieve this by simply using the distribution <code class="highlighter-rouge">dnUniformTopologyBranchLength()</code>.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>br_len_lambda &lt;- 10.0
psi ~ dnUniformTopologyBranchLength(taxa, branchLengthDistribution=dnExponential(br_len_lambda))
moves.append( mvNNI(psi, weight=num_taxa) )
moves.append( mvSPR(psi, weight=num_taxa/10.0) )
moves.append( mvBranchLengthScale(psi, weight=num_branches) )
</code></pre></div></div>
<p>You might think that this approach is in fact simpler than the <code class="highlighter-rouge">for</code> loop that we
explained above. We thought that it was pedagogical to specify the prior on
each branch length separately in this tutorial to emphasize all components of the model.</p>
</blockquote>

<blockquote class="aside"><h2>Alternative branch-length priors</h2><p>Some studies, <em>e.g.</em> <a class="citation" href="#Brown2010">Brown et al. (2010), Rannala et al. (2012)</a>,
have criticized the exponential prior distribution for branch lengths
because it induces a gamma-distributed tree-length and the mean of this gamma
distribution grows with the number of taxa. As an alternative, we can instead
use a specific gamma prior distribution (or any other distribution yielding a
positive real variable) for the tree length, and then use a Dirichlet prior
distribution to break the tree length into the corresponding branch lengths
<a class="citation" href="#Zhang2012">(Zhang et al. 2012)</a>.</p>

<p>First, specify a prior distribution on the tree length with your desired mean.
For example, we use a gamma distribution as our prior on the tree length.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL ~ dnGamma(2,4)
moves.append( mvScale(TL) )
</code></pre></div></div>

<p>Now we create a random variable for the relative branch lengths.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rel_branch_lengths ~ dnDirichlet( rep(1.0,num_branches) )
moves.append( mvBetaSimplex(rel_branch_lengths, weight=num_branches) )
moves.append( mvDirichletSimplex(rel_branch_lengths, weight=num_branches/10.0) )
</code></pre></div></div>
<p>Finally, transform the relative branch lengths into actual branch lengths</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>br_lens := rel_branch_lengths * TL
</code></pre></div></div>
</blockquote>

<h4 class="subsubsubsection" id="putting-it-all-together">Putting it All Together</h4>
<hr class="subsubsubsection" />

<p>We have fully specified all of the parameters of our phylogenetic
model‚Äîthe tree topology with branch lengths, and the substitution model
that describes how the sequence data evolve over the tree with branch
lengths. Collectively, these parameters comprise a distribution called
the <em>phylogenetic continuous-time Markov chain</em>, and we use the
<code class="highlighter-rouge">dnPhyloCTMC</code> constructor function to create this node. This
distribution requires several input arguments:</p>
<ol>
  <li>the <code class="highlighter-rouge">tree</code> with branch lengths;</li>
  <li>the instantaneous-rate matrix <code class="highlighter-rouge">Q</code>;</li>
  <li>the <code class="highlighter-rouge">type</code> of character data.</li>
</ol>

<p>Build the random variable for the character data (sequence alignment).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq ~ dnPhyloCTMC(tree=psi, Q=Q, type="DNA", nSites=num_sites)
</code></pre></div></div>

<h4 class="subsubsection" id="simulated-data">Simulated data</h4>
<hr class="subsubsection" />

<p>Building the <code class="highlighter-rouge">seq</code> random variable automatically simulated sequences. You can
output them to a file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writeFasta(filename="data/simulatedSequences_1.fasta", data=seq)
</code></pre></div></div>

<p>You can then view this alignment, for instance using
<a href="http://doua.prabi.fr/software/seaview">seaview</a>.</p>

<p>You can simulate another data set by ‚Äúredrawing‚Äù the random variable:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq.redraw()
</code></pre></div></div>

<p>And you can write the new sequences to another file:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>writeFasta(filename="data/simulatedSequences_2.fasta", data=seq)
</code></pre></div></div>
<ul>
  <li><strong>Are they different from the first ones?</strong></li>
</ul>

<p>It is always important to evaluate the realism of simulations. In our case, we
can compare the simulated alignment to the empirical alignment.
The sequence data objects (‚ÄúAbstractHomologousDiscreteCharacterData‚Äù)
have lots of functions that we can use for this purpose:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data.methods()
</code></pre></div></div>

<p>Let‚Äôs use some of them to compare the empirical data to the simulated data set:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print("Mean GC content of the empirical data: " + data.meanGcContent())
print("Mean GC content of the simulated data: " + seq.meanGcContent())
print("Variance of the GC content of the empirical data: " + data.varGcContent())
print("Variance of the GC content of the simulated data: " + seq.varGcContent())
</code></pre></div></div>
<ul>
  <li><strong>Can you think of other statistics that might be interesting to compute
to compare the empirical and the simulated data sets?</strong></li>
</ul>

<h3 class="subsection" id="performing-inference-with-the-jc-model-and-the-mcmc-algorithm">Performing inference with the JC model and the MCMC algorithm</h3>
<hr class="subsection" />

<p>In the first part of this tutorial, we saw how to simulate a DNA alignment
using the JC model.
The second part aims at performing inference under the JC model.</p>

<p>The inference script is called <code class="highlighter-rouge">scripts/mcmc_JC.Rev</code>.
You can run it in its entirety as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source("scripts/mcmc_JC.Rev")
</code></pre></div></div>

<p>If everything loaded properly, then you should see the program initiate
the Markov chain Monte Carlo analysis that estimates the posterior
distribution. If you continue to let this run, then you will see it
output the states of the Markov chain once the MCMC analysis begins.</p>

<p>Ultimately, this is how you will execute most analyses in RevBayes, with the full
specification of the model and analyses contained in the sourced files.
You could easily run this entire analysis on your own data by substituting your
data file name for that in the model-specification file. However, it is important
to understand the components of the model to be able to take full advantage of
the flexibility and richness of RevBayes. Furthermore, without inspecting the
Rev scripts sourced in <code class="highlighter-rouge">mcmc_JC.Rev</code>, you may end up inadvertently performing
inappropriate analyses on your dataset, which would be a waste of your time and
CPU cycles. The next steps will walk you through the full specification of the
model and MCMC analyses.</p>

<h4 class="subsubsection" id="additional-elements-in-the-inference-script">Additional elements in the inference script</h4>
<hr class="subsubsection" />

<p>Overall, the inference script is very similar to the simulation script. For instance,
the structure of the model is the same. However, to perform inference, additional
elements have to be included. In particular, the model that we were using for
simulation has to be <em>conditioned</em> upon observed data, the sequences at the tips.
Secondly, the whole model has to be assembled into a <em>model</em> variable, upon
which MCMC sampling will be able to operate. Thirdly, <em>moves</em> need to be specified for
each stochastic variable, so that we can obtain posterior distributions. Recall
that moves are algorithms used to propose new parameter values during the MCMC
simulation. Fourthly, we may want to specify <em>monitors</em> to record parameter
values as the MCMC algorithm proceeds. Monitors print the values of model parameters
to the screen and/or log files during the MCMC analysis.</p>

<h4 class="subsubsubsection" id="conditioning-the-model-on-observed-data">Conditioning the model on observed data</h4>
<hr class="subsubsubsection" />

<p>The <code class="highlighter-rouge">PhyloCTMC</code> model is able to produce sequence alignments, given parameter
variables. We can attach our sequence data to the tip nodes in the tree:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seq.clamp(data)
</code></pre></div></div>

<p>Note that although we assume that our sequence data are random
variables‚Äîthey are realizations of our phylogenetic model‚Äîfor the
purposes of inference, we assume that the sequence data are ‚Äúclamped‚Äù to their
observed values.
When this function is called, RevBayes sets each of the stochastic
nodes representing the tips of the tree to the corresponding nucleotide
sequence in the alignment. This essentially tells the program that we
have observed data for the sequences at the tips: we are <em>conditioning</em> the
model on these data.</p>

<h4 class="subsubsubsection" id="assembling-the-constant-deterministic-and-stochastic--variables-into-a-model">Assembling the constant, deterministic and stochastic
  variables into a model</h4>
<hr class="subsubsubsection" />

<p>We wrap the entire model in a single object to provide convenient access to the
Directed Acyclic Graph. To do this, we only need to give the <code class="highlighter-rouge">model()</code> function a single
node of the model. Starting from this node, the <code class="highlighter-rouge">model()</code> function can find all of the other
nodes by following the arrows in the graphical model:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel = model(Q)
</code></pre></div></div>

<p>Now we have specified a simple phylogenetic model‚Äîeach parameter of
the model will be estimated from every site in our alignment. If we
inspect the contents of <code class="highlighter-rouge">mymodel</code> we can review all of the nodes in the
DAG:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymodel
</code></pre></div></div>

<h4 class="subsubsubsection" id="adding-moves-to-the-script">Adding moves to the script</h4>
<hr class="subsubsubsection" />

<p>For each stochastic variable of the model, we need to specify a move. If no move
is specified for a stochastic variable, this variable will stay constant throughout
the entire algorithm.</p>

<p>First we create a vector to store all the moves that will be used to sample from
the posterior distribution:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves = VectorMoves()
</code></pre></div></div>

<p>You may have noticed that we used the <code class="highlighter-rouge">=</code> operator to create the move index.
This simply means that the variable is not part of the model: it is not used to
compute the probability of a set of parameter values. Instead, it is a part
of the MCMC algorithm.
You will later see that we use this operator for other variables that are not
part of the model, e.g., when we create moves and monitors.</p>

<p>For instance, we specify a move
for the tree topology.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>moves.append( mvNNI(topology, weight=3) )
</code></pre></div></div>

<p>Some types of stochastic nodes, and the tree topology in particular, can be
updated by a number of alternative moves.
Different moves may explore parameter space in different ways,
and it is possible to use multiple different moves for a given parameter to improve mixing
(i.e. the efficiency of the MCMC simulation).
In the case of our unrooted tree topology, for example, we can use both a
nearest-neighbor interchange move <a href="#nni"></a> (<code class="highlighter-rouge">mvNNI</code> in the Rev language) and a subtree-prune and regraft move <a href="#spr"></a> (<code class="highlighter-rouge">mvSPR</code> in the Rev language, currently commented in the script).</p>

<figure id="nni"><p><img src="figures/NNI.svg.png" /></p>
<figcaption>The NNI move swaps two subtrees around an internal branch. Source: <a href="https://en.wikipedia.org/wiki/Tree_rearrangement">https://en.wikipedia.org/wiki/Tree_rearrangement</a></figcaption>
</figure>

<figure id="spr"><p><img src="figures/800px-SPR.svg.png" /></p>
<figcaption>The SPR moves prunes a subtree, and reattaches it somewhere else in the tree. Source: <a href="https://en.wikipedia.org/wiki/Tree_rearrangement">https://en.wikipedia.org/wiki/Tree_rearrangement</a></figcaption>
</figure>

<p>These moves do not have tuning parameters associated with them, thus we only need
to pass in the <code class="highlighter-rouge">topology</code> node and proposal <code class="highlighter-rouge">weight</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># moves.append( mvSPR(topology, weight=3) )
</code></pre></div></div>

<p>The weight specifies how often the move will be applied either on average per
iteration or relative to all other moves. Have a look at the
<a href="https://revbayes.github.io/tutorials/">MCMC tutorials</a> for more details
about moves and MCMC strategies.</p>

<p>The other stochastic variables in the model are branch lengths. They need their
own moves:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i in 1:num_branches) {
    moves.append( mvScale(bl[i]) )
}
</code></pre></div></div>

<p>Here each branch length is associated to a <code class="highlighter-rouge">mvScale</code> move that basically multiplies
the current value of a branch length by a real positive number.</p>

<ul>
  <li><strong>What type of stochastic variable is particularly appropriate for the <code class="highlighter-rouge">mvScale</code>
move?</strong></li>
</ul>

<h4 class="subsubsubsection" id="specifying-monitors-and-output-files">Specifying Monitors and Output Files</h4>
<hr class="subsubsubsection" />

<p>During the MCMC analysis, we can decide to keep track of all the sampled parameters,
but also of various statistics that we think may be of interest. Here, we have
decided to keep track of the tree length, i.e. the sum of all branch lengths.
To this end, we add a variable <code class="highlighter-rouge">TL</code> that will compute this sum. Accordingly, the tree
length can be computed using the <code class="highlighter-rouge">sum()</code> function, which calculates the sum of
any vector of values.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TL := sum(br_lens)
</code></pre></div></div>

<ul>
  <li><strong>Why are we using ‚Äú:=‚Äù here?</strong></li>
</ul>

<p>For our MCMC analysis, we need to set up a vector of <em>monitors</em> to
record the states of our Markov chain. The monitor functions are all
called <code class="highlighter-rouge">mn\*</code>, where <code class="highlighter-rouge">\*</code> is the wild-card representing the monitor type.
First, we will initialize the model monitor using the <code class="highlighter-rouge">mnModel</code>
function. This creates a new monitor variable that will output the
states for all model parameters when passed into a MCMC function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors = VectorMonitors()

monitors.append( mnModel(filename="analyses/primates_cytb_JC.log", printgen=10) )
</code></pre></div></div>

<p>The <code class="highlighter-rouge">mnFile</code> monitor will record the states for only the parameters
passed in as arguments. We use this monitor to specify the output for
our sampled phylograms.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnFile(filename="analyses/primates_cytb_JC.trees", printgen=10, psi) )
</code></pre></div></div>

<p>Finally, we create a screen monitor that will report the states of
specified variables to the screen with <code class="highlighter-rouge">mnScreen</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitors.append( mnScreen(printgen=100, TL) )
</code></pre></div></div>

<p>This monitor mostly helps us to see the progress of the MCMC run.</p>

<h4 class="subsubsection" id="initializing-and-running-the-mcmc-simulation">Initializing and Running the MCMC Simulation</h4>
<hr class="subsubsection" />

<p>With a fully specified model, a set of monitors, and a set of moves, we
can now set up the MCMC algorithm that will sample parameter values in
proportion to their posterior probability. The <code class="highlighter-rouge">mcmc()</code> function will
create our MCMC object:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves)
</code></pre></div></div>

<p>Now, run the MCMC:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=2500)
</code></pre></div></div>
<p>Here we set a low number of iterations. In general it is recommended to check
for convergence; here it is possible that 2500 iterations may not be enough.</p>

<p>When the analysis is complete, you will have the files produced by the monitors
in your <code class="highlighter-rouge">analyses</code> directory.</p>

<blockquote class="aside"><h2>Saving and restarting analyses</h2><p>MCMC analyses can take a long time to converge, and it is usually difficult to
predict how many generations will be needed to obtain results. In addition, many
analyses are run on computer clusters with time limits, and so may be stopped by
the cluster partway through. For all of these reasons, it is useful to save the
state of the chain regularly through the analysis.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.run(generations=100000000, checkpointInterval=100, checkpointFile="analyses/primates_cytb_JC.state")
</code></pre></div></div>

<p>The <code class="highlighter-rouge">checkpointInterval</code> and <code class="highlighter-rouge">checkpointFile</code> inputs specify respectively how
often, and to which file, the chain should be saved. Three different files will
be used for storing the state: one with no extension, one with extension <code class="highlighter-rouge">_mcmc</code>,
 and one with extension <code class="highlighter-rouge">_moves</code>.
When multiple independent runs are specified, they will automatically be saved
in separate files (with extensions <code class="highlighter-rouge">_run_1</code>, <code class="highlighter-rouge">_run_2</code>, etc.).</p>

<p>Restarting the chain from a previous run is done by adding this line:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc.initializeFromCheckpoint("analyses/primates_cytb_JC.state")
</code></pre></div></div>
<p>before calling the function <code class="highlighter-rouge">mcmc.run()</code>. The file name should match what was given as <code class="highlighter-rouge">checkpointFile</code> when running the previous analysis. <strong>NB:</strong> Note that this line will create an error if the state file does not exist yet, and so should be commented out in the first run.</p>

<p>The full MCMC block thus becomes:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mymcmc = mcmc(mymodel, monitors, moves, nruns=1)
mymcmc.initializeFromCheckpoint("analyses/primates_cytb_JC.state") #comment this out for the first run

mymcmc.run(generations=100000000, checkpointInterval=100, checkpointFile="analyses/primates_cytb_JC.state")
</code></pre></div></div>
</blockquote>

<h4 class="subsubsection" id="summarizing-mcmc-samples">Summarizing MCMC Samples</h4>
<hr class="subsubsection" />

<p>Methods for visualizing the marginal densities of parameter values are not
currently available in RevBayes itself.
Thus, it is important to use programs like
<a href="http://tree.bio.ed.ac.uk/software/tracer/">Tracer</a> <a class="citation" href="#Rambaut2011">(Rambaut and Drummond 2011)</a>
to evaluate mixing and non-convergence.</p>

<p>Look at the file called <code class="highlighter-rouge">analyses/primates_cytb_JC.log</code> in Tracer.
There you see the posterior distribution of the continuous parameters,
<em>e.g.</em>, the tree length variable <code class="highlighter-rouge">TL</code>.</p>

<figure id="jc_trace_tl"><p><img src="figures/primates_cytb_JC_TL_Trace.png" width="500" /> <img src="figures/primates_cytb_JC_TL_Distribution.png" width="500" /></p>
<figcaption><strong>Left:</strong> Trace of tree-length samples for one MCMC run. The caterpillar-like
look is a good sign. You will also see that the effective sample size is
comparably large, i.e., much larger than 200.
<strong>Right:</strong> Posterior distribution of the tree length of the primate
phylogeny under a Jukes-Cantor substitution model.</figcaption>
</figure>

<p>It is always important to carefully assess the MCMC samples for the various
parameters in your analysis.
You can read more about MCMC tuning and evaluating and improving mixing in the
other tutorials on <a href="https://revbayes.github.io/tutorials/">the RevBayes website</a>.</p>

<h3 class="subsection" id="analyzing-the-inferred-phylogeny">Analyzing the inferred phylogeny</h3>
<hr class="subsection" />

<p>We are interested in the phylogenetic relationship of the Tarsiers.
Therefore, we need to summarize the trees sampled from the posterior
distribution. RevBayes can summarize the sampled trees by reading in
the tree-trace file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>treetrace = readTreeTrace("analyses/primates_cytb_JC.trees", treetype="non-clock")
</code></pre></div></div>

<p>The <code class="highlighter-rouge">mapTree()</code> function will summarize the tree samples and write the
maximum <em>a posteriori</em> tree to file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>map_tree = mapTree(treetrace,"analyses/primates_cytb_JC_MAP.tree")
</code></pre></div></div>

<figure id="jc_tree"><p><img src="figures/primates_cytb_JC_tree.png" width="800" /></p>
<figcaption>Maximum a posteriori estimate of the primate phylogeny under a Jukes-Cantor
substitution model. The numbers at the nodes show the posterior probabilities
for the clades. We have rooted the tree at the outgroup <em>Galeopterus_variegatus</em></figcaption>
</figure>

<p>Look at the file called <code class="highlighter-rouge">analyses/primates_cytb_JC_MAP.tree</code> in
<code class="highlighter-rouge">FigTree</code>. We show it in <a href="#jc_tree"></a>.</p>

<p>Note, you can query the posterior probability of a particular clade being
monophyletic using the following command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Lemuroidea &lt;- clade("Cheirogaleus_major",
                    "Daubentonia_madagascariensis",
                    "Lemur_catta",
                    "Lepilemur_hubbardorum",
                    "Microcebus_murinus",
                    "Propithecus_coquereli",
                    "Varecia_variegata_variegata")

treetrace.cladeProbability( Lemuroidea )
</code></pre></div></div>

<h2 class="section" id="conclusion">Conclusion</h2>
<hr class="section" />

<p>During this tutorial, we used the simplest phylogenetic model to first simulate
data, and then infer a phylogeny given an empirical data set.
Sequence simulation is often used to test inference methods.</p>
<ul>
  <li><strong>What could you learn by performing MCMC inference on a simulated data set?</strong></li>
  <li><strong>Combine the scripts to perform inference on simulated data.</strong></li>
</ul>

<p>Sequence simulation is also often used to assess <em>model adequacy</em>, i.e. to ask
if my model can reproduce the important features of the empirical data set.</p>
<ul>
  <li><strong>Based on a comparison of the empirical and simulated alignments, do you
think that the JC model is adequate for this data set?</strong></li>
</ul>

<p>In the next tutorial, you will learn about more sophisticated models of
sequence evolution.</p>
:ET