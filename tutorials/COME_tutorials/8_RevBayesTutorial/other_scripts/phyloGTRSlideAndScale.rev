data <- readDiscreteCharacterData("data/test.fa")

output_name <- "testGTRSlideAndScale"


# We extract the number of species, branches, and the taxon labels from the data.
n_species <- data.ntaxa()
n_branches <- 2 * n_species - 3
taxa <- data.taxa()

# Let's define an outgroup, so that the output trees are written consistently
# with the first bifurcation between the outgroup and the other sequences.
out_group = clade("Loach")

# We define a uniform prior on (undated) tree topologies.
topology ~ dnUniformTopology(taxa, outgroup = out_group)

# We define exponential priors of mean 1/10 for branch lengths.
for (i in 1:n_branches) {
 bls[i] ~ dnExponential(10.0)
}

# We assemble the topology "topology" and branch lengths bls to get a phylogeny psi.
psi := treeAssembly(topology, bls)

# We compute the total tree length, just for monitoring.
TL := sum(bls)


# We define a GTR substitution process
## Exchangeabilities rho:
rho ~ dnDirichlet([1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
## Equilibrium frequencies pi:
pi ~ dnDirichlet([1.0, 1.0, 1.0, 1.0])
## We combine them into a GTR matrix Q:
Q := fnGTR(exchangeRates=rho, baseFrequencies=pi)

# We allow for rate heterogeneity across sites:
alpha ~ dnUniform( 0.0, 10 )
sr := fnDiscretizeGamma( alpha, alpha, 4 )

# Sequences are distributed according to a Continuous Time Markov Chain
# running along the phylogeny psi, using the substitution matrix Q.
seq ~ dnPhyloCTMC( tree=psi, Q=Q, siteRates=sr, type="DNA" )

# So far, we have defined the model, which can be used for simulation or
# for inference. To use the model for inference, we need to link the model to the
# observed data, by clamping the "seq" node to the data.
seq.clamp( data )

# We declare the model as one big object that we are going to use in the MCMC.
my_model = model(psi)

# For the MCMC to run, we need to define moves on the various stochastic variables
# that we have defined.

# We store all moves in a vector.
moves = VectorMoves()

# We define 2 moves on the topology.
moves.append(mvNNI(topology, weight=3.0))
moves.append(mvSPR(topology, weight=3.0))

# We define moves on the branch lengths, for each branch.
for (i in 1:n_branches) {
   moves.append(mvScale(bls[i], tune=TRUE))
   moves.append(mvSlide(bls[i], tune=TRUE))
}

# We define moves on the parameters of the substitution matrix.
moves.append(mvDirichletSimplex(rho, weight=1.0, alpha=10, tune=TRUE))
moves.append(mvDirichletSimplex(pi, weight=1.0, alpha=10, tune=TRUE))

# And we define a move on the parameter of the gamma distribution for rate heterogeneity across sites:
moves.append( mvScale(alpha, weight=2.0, tune=TRUE) )
moves.append( mvSlide(alpha, weight=2.0, tune=TRUE) )

# Now we define monitors to keep trace of what's happening during the MCMC.
# One monitor to store the parameter distributions into a file.
monitors[1] = mnModel(filename="analyses/"+output_name+".log", printgen=10, separator = TAB)

# One monitor to store the trees.
monitors[2] = mnFile(psi,filename="analyses/"+output_name+".trees", printgen=10, separator = TAB)

# One monitor to show information on the screen.
monitors[3] = mnScreen(printgen=100, TL, alpha)

# Create an MCMC object.
analysis = mcmc(my_model, monitors, moves)

# We run burnin during a few iterations
analysis.burnin(generations=3000, tuningInterval=300)

# We run the MCMC for 10,000 iterations.
analysis.run(10000)

# Post-analysis
# Let's look at move statistics:
analysis.operatorSummary()


# we construct the maximum a posteriori tree
treetrace = readTreeTrace("analyses/"+output_name+".trees", treetype="non-clock", burnin=0.1)
map_tree = mapTree(treetrace, "analyses/"+output_name+"_map.tree")
