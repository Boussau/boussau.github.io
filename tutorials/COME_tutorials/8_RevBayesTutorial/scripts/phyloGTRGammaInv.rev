
#############################################
# Input and output data, general variables  #
#############################################

# We read the alignment:
data = readDiscreteCharacterData("data/test.fa")

# We extract the number of species, branches, and the taxon labels from the data:
n_species = data.ntaxa()
n_branches = 2 * n_species - 3
taxa = data.taxa()

# We create a vector of moves to store them all:
moves = VectorMoves()

# We decide on a stub name for the output files:
output_stub = "testGTRGammaInv"


################################
# Topology and branch lengths  #
################################

# Let's define an outgroup for our tree, so that the output trees are written consistently
# with the first bifurcation between the outgroup and the other sequences:
out_group <- clade("Loach")

# We define a uniform prior on (undated) tree topologies:
topology ~ dnUniformTopology(taxa, outgroup = out_group)

# We define exponential priors of mean 1/10 for branch lengths:
for (i in 1:n_branches) {
 bls[i] ~ dnExponential(10.0)
}

# We assemble the topology "topology" and branch lengths bls to get a phylogeny psi:
psi := treeAssembly(topology, bls)

# We compute the total tree length, just for monitoring:
TL := sum(bls)

# For the MCMC to run, we need to define moves on the various stochastic variables
# that we have defined.

# We define 2 moves on the topology.
moves.append(mvNNI(topology, weight=10.0))
moves.append(mvSPR(topology, weight=10.0))

# We define moves on the branch lengths, one for each branch.
for (i in 1:n_branches) {
   moves.append(mvScaleBactrian(bls[i], tune=TRUE))
}

########################
# Substitution matrix  #
########################

# We define a GTR substitution process:
## Exchangeabilities rho:
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
## Equilibrium frequencies pi:
pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
## We combine them into a GTR matrix Q:
Q := fnGTR(exchangeRates=er, baseFrequencies=pi)

# We define moves on the parameters of the substitution matrix:
moves.append( mvBetaSimplex(er, weight=3) )
moves.append( mvDirichletSimplex(er, weight=1.0, alpha=10, tune=TRUE))
moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1.0, alpha=10, tune=TRUE))


####################################
# Rate heterogeneity across sites  #
####################################

# We allow for rate heterogeneity across sites:
alpha ~ dnUniform( 0.0, 10 )
sr := fnDiscretizeGamma( alpha, alpha, 4 )

# We define a move on the parameter of the gamma distribution for rate heterogeneity across sites:
moves.append( mvScaleBactrian(alpha, weight=2.0, tune=TRUE) )


##################################
# Proportion of invariant sites  #
##################################

# We model the proportion of invariant sites
p_inv ~ dnBeta(1,1)

# We define a move on the proportion of invariant sites parameter
moves.append( mvSlide(p_inv, tune=TRUE) )


#########
# CTMC  #
#########

# Sequences are distributed according to a Continuous Time Markov Chain
# running along the phylogeny psi, using the substitution matrix Q,
# and assuming rate heterogeneity across sites.
seq ~ dnPhyloCTMC( tree=psi, Q=Q, siteRates=sr, pInv=p_inv, type="DNA")

###################################
# Clamping the model to the data  #
###################################

# So far, we have defined the model, which can be used for simulation or
# for inference. To use the model for inference, we need to condition the model on the
# observed data, by clamping the "seq" node to the data.
seq.clamp( data )


##################
# MCMC analysis  #
##################

# We declare the model as one big object that we are going to use in the MCMC:
my_model = model(psi)

# Now we define monitors to keep track of what's happening during the MCMC.
# We use the stub name
# One monitor to store the parameter distributions into a file:
monitors[1] = mnModel(filename="analyses/"+output_stub+".log", printgen=10, separator = TAB)

# One monitor to store the trees:
monitors[2] = mnFile(psi,filename="analyses/"+output_stub+".trees", printgen=10, separator = TAB)

# One monitor to show information on the screen:
monitors[3] = mnScreen(printgen=100, TL, alpha, p_inv)

# We create an MCMC object:
analysis = mcmc(my_model, monitors, moves, nruns = 2, combine = "sequential")

# We run burnin during a few iterations:
analysis.burnin(generations=1000, tuningInterval=100)

# Let's look at move statistics for the burnin:
analysis.operatorSummary()

# We run the MCMC for 10,000 iterations:
analysis.run(10000)


#######################
# Post MCMC analysis  #
#######################

# Let's look at move statistics for the whole analysis:
analysis.operatorSummary()

# we construct the maximum a posteriori tree
treetrace = readTreeTrace("analyses/"+output_stub+".trees", treetype="non-clock", burnin=0.1)
map_tree = mapTree(treetrace, "analyses/"+output_stub+"_map.tree")

############
# Bye-bye  #
############
q()
