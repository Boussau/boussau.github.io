#############################################
# Input and output data, general variables  #
#############################################

# We read the alignment:
data = readDiscreteCharacterData("data/test.fa")

# We extract the number of species, branches, and the taxon labels from the data:
n_species = data.ntaxa()
n_branches = 2 * n_species - 3
taxa = data.taxa()

# We create a vector of moves to store them all:
moves = VectorMoves()

# We decide on a stub name for the output files:
output_stub = "ppGTRGammaInv"


################################
# Topology and branch lengths  #
################################

# Let's define an outgroup for our tree, so that the output trees are written consistently
# with the first bifurcation between the outgroup and the other sequences:
out_group <- clade("Loach")

# We define a uniform prior on (undated) tree topologies:
topology ~ dnUniformTopology(taxa, outgroup = out_group)

# We define exponential priors of mean 1/10 for branch lengths:
for (i in 1:n_branches) {
 bls[i] ~ dnExponential(10.0)
}

# We assemble the topology "topology" and branch lengths bls to get a phylogeny psi:
psi := treeAssembly(topology, bls)

# We compute the total tree length, just for monitoring:
TL := sum(bls)

# For the MCMC to run, we need to define moves on the various stochastic variables
# that we have defined.

# We define 2 moves on the topology.
moves.append(mvNNI(topology, weight=10.0))
moves.append(mvSPR(topology, weight=10.0))

# We define moves on the branch lengths, one for each branch.
for (i in 1:n_branches) {
   moves.append(mvScaleBactrian(bls[i], tune=TRUE))
}

######################
# Substitution Model #
######################

# We define a GTR substitution process:
## Exchangeabilities rho:
er_prior <- v(1,1,1,1,1,1)
er ~ dnDirichlet(er_prior)
## Equilibrium frequencies pi:
pi_prior <- v(1,1,1,1)
pi ~ dnDirichlet(pi_prior)
## We combine them into a GTR matrix Q:
Q := fnGTR(exchangeRates=er, baseFrequencies=pi)

# We define moves on the parameters of the substitution matrix:
moves.append( mvBetaSimplex(er, weight=3) )
moves.append( mvDirichletSimplex(er, weight=1.0, alpha=10, tune=TRUE))
moves.append( mvBetaSimplex(pi, weight=2) )
moves.append( mvDirichletSimplex(pi, weight=1.0, alpha=10, tune=TRUE))

####################################
# Rate heterogeneity across sites  #
####################################

# We allow for rate heterogeneity across sites:
alpha ~ dnUniform( 0.0, 10 )
sr := fnDiscretizeGamma( alpha, alpha, 4 )

# We define a move on the parameter of the gamma distribution for rate heterogeneity across sites:
moves.append( mvScaleBactrian(alpha, weight=2.0, tune=TRUE) )

##################################
# Proportion of invariant sites  #
##################################

# We model the proportion of invariant sites
p_inv ~ dnBeta(1,1)

# We define a move on the proportion of invariant sites parameter
moves.append( mvSlide(p_inv, tune=TRUE) )

#########
# CTMC  #
#########

# Sequences are distributed according to a Continuous Time Markov Chain
# running along the phylogeny psi, using the substitution matrix Q,
# and assuming rate heterogeneity across sites.
seq ~ dnPhyloCTMC( tree=psi, Q=Q, siteRates=sr, pInv=p_inv, type="DNA")


###################################
# Clamping the model to the data  #
###################################

# So far, we have defined the model, which can be used for simulation or
# for inference. To use the model for inference, we need to condition the model on the
# observed data, by clamping the "seq" node to the data.
seq.clamp( data )


##################
# MCMC analysis  #
##################

# We declare the model as one big object that we are going to use in the MCMC:
my_model = model(psi)

# One monitor to show information on the screen:
monitors[1] = mnScreen(printgen=100, TL)

# We create a power-posterior object:
pow_p = powerPosterior(my_model, moves, monitors, filename="analyses/"+output_stub+".out", sampleFreq=5, cats=20)

# We run _each stone_ MCMC for 5,000 iterations:
pow_p.run(generations=5000)

#######################
# Post MCMC analysis  #
#######################

# compute the marginal likelihood with the path-sampling equation
ps = pathSampler(file="analyses/"+output_stub+".out", powerColumnName="power", likelihoodColumnName="likelihood")
print("Marginal likelihood (path sampling):  " + ps.marginal())

# compute the marginal likelihood with the stepping-stone equation
ss = steppingStoneSampler(file="analyses/"+output_stub+".out", powerColumnName="power", likelihoodColumnName="likelihood")
print("Marginal likelihood (stepping-stone): " + ss.marginal())

############
# Bye-bye  #
############
q()
