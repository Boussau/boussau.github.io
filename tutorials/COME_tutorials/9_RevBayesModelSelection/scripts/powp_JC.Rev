#############################################
# Input and output data, general variables  #
#############################################

# We read the alignment:
data = readDiscreteCharacterData("data/test.fa")

# We extract the number of species, branches, and the taxon labels from the data:
n_species = data.ntaxa()
n_branches = 2 * n_species - 3
taxa = data.taxa()

# We create a vector of moves to store them all:
moves = VectorMoves()

# We decide on a stub name for the output files:
output_stub = "ppJC"


################################
# Topology and branch lengths  #
################################

# Let's define an outgroup for our tree, so that the output trees are written consistently
# with the first bifurcation between the outgroup and the other sequences:
out_group <- clade("Loach")

# We define a uniform prior on (undated) tree topologies:
topology ~ dnUniformTopology(taxa, outgroup = out_group)

# We define exponential priors of mean 1/10 for branch lengths:
for (i in 1:n_branches) {
 bls[i] ~ dnExponential(10.0)
}

# We assemble the topology "topology" and branch lengths bls to get a phylogeny psi:
psi := treeAssembly(topology, bls)

# We compute the total tree length, just for monitoring:
TL := sum(bls)

# For the MCMC to run, we need to define moves on the various stochastic variables
# that we have defined.

# We define 2 moves on the topology.
moves.append(mvNNI(topology, weight=10.0))
moves.append(mvSPR(topology, weight=10.0))

# We define moves on the branch lengths, one for each branch.
for (i in 1:n_branches) {
   moves.append(mvScaleBactrian(bls[i], tune=TRUE))
}

######################
# Substitution Model #
######################

# create a constant variable for the rate matrix
Q <- fnJC(4)

#########
# CTMC  #
#########

# Sequences are distributed according to a Continuous Time Markov Chain
# running along the phylogeny psi, using the substitution matrix Q,
# and assuming no rate heterogeneity across sites.
seq ~ dnPhyloCTMC( tree=psi, Q=Q, type="DNA" )


###################################
# Clamping the model to the data  #
###################################

# So far, we have defined the model, which can be used for simulation or
# for inference. To use the model for inference, we need to condition the model on the
# observed data, by clamping the "seq" node to the data.
seq.clamp( data )


##################
# MCMC analysis  #
##################

# We declare the model as one big object that we are going to use in the MCMC:
my_model = model(psi)

# One monitor to show information on the screen:
monitors[1] = mnScreen(printgen=100, TL)

# We create a power-posterior object:
pow_p = powerPosterior(my_model, moves, monitors, filename="analyses/"+output_stub+".out", sampleFreq=5, cats=20)

# We run _each stone_ MCMC for 5,000 iterations:
pow_p.run(generations=5000)

#######################
# Post MCMC analysis  #
#######################

# compute the marginal likelihood with the path-sampling equation
ps = pathSampler(file="analyses/"+output_stub+".out", powerColumnName="power", likelihoodColumnName="likelihood")
print("Marginal likelihood (path sampling):  " + ps.marginal())

# compute the marginal likelihood with the stepping-stone equation
ss = steppingStoneSampler(file="analyses/"+output_stub+".out", powerColumnName="power", likelihoodColumnName="likelihood")
print("Marginal likelihood (stepping-stone): " + ss.marginal())

############
# Bye-bye  #
############
q()
